***

## Phase 3 개발 지침 (SSOT)
### 목적과 비목적
Phase 3의 목적은 Phase 2에서 생성된 `signals.search_queries[]`를 사용해 교재에서 관련 청크를 **최대한 많이 수집**하고, 이를 `evidence_candidates`에 저장하는 것이다(Recall 우선).[1]
Phase 3는 **엄격한 검증/최종 판정/중복 제거**를 하지 않으며, 그 책임은 Phase 4(Reduce)가 가진다.[1]

***

## 입력/출력 계약
### 입력(필수)
- `session_id` (대상 세션)[1]
- 해당 세션의 `signals` 전부(또는 범위 지정)[1]
- 각 signal의 `search_queries[]` (교재 수집을 위한 검색어 리스트)[1]

### 출력(필수)
- `evidence_candidates` 레코드 다수 삽입(중복 허용)[1]
- 각 후보에는 최소한 다음이 포함되어야 한다.
  - `session_id`
  - `signal_id` (어떤 신호에서 유래했는지 추적) *(v3.0 보강 사항)*
  - `chunk_id`
  - `query_used` (어떤 검색어로 찾았는지)[1]

### 출력(권장: Phase 4 품질/디버깅 강화)
- `retrieval_channel ∈ {vector, keyword, rrf}`
- `rank_vector`, `rank_keyword`
- `score_vector`, `score_keyword`, `rrf_score`  
이 메타는 Phase 4에서 “근거 강도” 판단에 활용되며, 원인 분석(왜 이 근거가 들어왔는지)을 가능하게 한다.[1]

***

## 처리 흐름(알고리즘)
### 1) Query Plan 생성(세션 단위)
1. `signals`를 `chunk_index, t0_sec` 기준으로 로드(순서는 디버깅 편의용).[1]
2. 각 `signal`에 대해 `search_queries[]`를 펼쳐 `(signal_id, query_text)` 단위의 작업 목록을 만든다.[1]
3. 동일/유사 쿼리 중복을 줄이기 위해 다음 정규화를 권장한다.
- Trim, lower, 연속 공백 축소
- 길이 제한(예: 4~120 chars) 및 공백/기호만 있는 쿼리 제거
- 세션 단위 `query_hash = sha1(normalized_query)`로 캐싱(선택)

> 주의: “세션 단위 쿼리 캐싱”을 해도 `signal_id → 후보` 추적은 유지해야 하므로, 캐시된 결과를 재사용하더라도 삽입은 `signal_id`별로 수행한다.[1]

### 2) Hybrid Retrieval 실행(쿼리 단위)
v3.0는 Phase 3에서 하이브리드 검색을 사용하며, DB 내부에서 `pgvector`(의미) + `pg_trgm`(키워드)을 함께 돌려 후보를 모은 뒤 RRF로 합친다.[1]

권장 구성:
- Vector channel:
  - 입력: `query_text`
  - 출력: Top `k_vector` (예: 20~50)
- Keyword channel:
  - 입력: `query_text`
  - 출력: Top `k_keyword` (예: 20~50)
  - 구현: `pg_trgm` 기반 trigram similarity(예: `%`/유사도 함수) 사용 *(SSOT 문구로 고정 권장)*
- Merge:
  - RRF(Reciprocal Rank Fusion)로 `k_final` (예: 30~80) 산출[1]

### 3) Evidence Candidate 저장(쿼리 단위, 중복 허용)
각 `(signal_id, query_text)`에 대해 최종 Top-K 결과를 `evidence_candidates`에 삽입한다.[1]

삽입 규칙(중요):
- **중복 삽입 허용**: 같은 `chunk_id`가 여러 쿼리/여러 signal에서 들어오는 것은 정상이며, Phase 4에서 `chunk_id` 기준 dedup한다.[1]
- 반드시 `signal_id`를 저장해, “어떤 신호가 어떤 후보를 가져왔는지”를 나중에 분석 가능하게 한다.[1]

***

## In-DB RPC 권장 설계 (Actual Implementation v3.1)
Phase 3는 “워커가 검색 로직을 직접 구현”하는 대신, DB RPC로 검색을 캡슐화하면(단일 SSOT) 운영/튜닝이 단순해진다.[1]

### RPC: `hybrid_search_rrf(...)` (구현 완료)
입력 파라미터:
- `p_query_text TEXT`: 검색어 (Keyword Search용)
- `p_query_embedding halfvec(768)`: 임베딩 벡터 (Vector Search용)
- `p_match_count INT`: 최종 반환할 Top-K 개수 (예: 50)
- `p_rrf_k INT DEFAULT 60`: RRF 상수 (Rank Fusion 튜닝용)
- `p_full_text_weight FLOAT`, `p_semantic_weight FLOAT` (Reserved, 현재 1.0)

내부 로직:
1. **Vector Search**: `p_match_count * 2` (예: 100개) 후보 검색 (Cosine Distance).
2. **Keyword Search**: `p_match_count` (예: 50개) 후보 검색 (`pg_trgm` Similarity).
3. **RRF Merge**: `1 / (k + rank)` 공식으로 점수 합산 및 정렬, 최종 `p_match_count` 반환.

출력:
- `chunk_id UUID`
- `rank_vector INT`, `rank_keyword INT`
- `score_vector FLOAT`, `score_keyword FLOAT`
- `rrf_score FLOAT`
- (표시/인용용 메타) `page_start, page_end, anchor_path`

***

## 성능/예산(현실적인 기본값)
초기 운영 기본값(v3.1 적용):
- `FINAL_K = 50` (RPC `p_match_count`)
- `RRF_C = 60`
- **Parallel Execution**: `ThreadPoolExecutor(max_workers=20)` 사용하여 다수 쿼리(수백 개)를 동시 처리.
  - 최적화: `query_text` 기준 중복 제거(Deduplication) 후 검색 실행, 결과는 `signal_id`별로 매핑하여 저장.

DB/인덱스 전제:
- `chunks.embedding halfvec(768)` + HNSW 인덱스가 존재해야 한다.[1]
- `chunks.content_text`에 `pg_trgm` GIN 인덱스가 존재해야 한다.[1]

***

## 관측/디버깅(필수 로그)
Phase 3에서 반드시 남겨야 하는 “원인 분석 로그”는 아래다.

- 세션/신호/쿼리 단위
  - `session_id`, `signal_id`, `query_used`
  - 검색 예산: `k_vector/k_keyword/k_final`
  - 결과 수: vector hits, keyword hits, final hits
- 후보 단위
  - `chunk_id`, `rrf_score`, `rank_vector/rank_keyword`
  - `retrieval_channel`

이 정보는 “어떤 query가 후보를 못 가져왔는지”, “어떤 채널이 기여했는지”를 빠르게 파악하게 해준다.[1]

***

## 실패 처리/재시도(Phase 3)
Phase 3는 Recall을 책임지므로, 실패 시 보수적으로 재시도한다.[1]

- DB RPC 실패/타임아웃: 동일 쿼리 1회 재시도
- 결과 0건:
  - (1) `k_vector/k_keyword` 상향 후 1회 재시도
  - (2) 그래도 0이면 `evidence_candidates`는 비어 있을 수 있으며, Phase 4에서 해당 신호는 “근거 없음”으로 제외될 수 있다(정상 동작).[1]

***

## 최소 테스트 케이스(개발 완료 기준)
- 입력: signals 10개, query 총 30개
  - 기대: `evidence_candidates`가 (30 * k_final) 근처로 누적되며, 중복이 존재해도 정상[1]
- 입력: 의도적으로 희귀 쿼리(결과 0)
  - 기대: 재시도 후에도 0이면 해당 쿼리는 스킵/기록되고 파이프라인은 진행[1]
- 검증: `evidence_candidates.signal_id`가 항상 채워져 추적 가능

***